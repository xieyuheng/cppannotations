    The i(lexical scanner specification file) is organized comparably to the
one used for tt(flex) in bf(C) contexts. However, in bf(C++) contexts,
tt(flexc++) creates a class tt(Scanner), rather than just a scanner function.

Flexc++'s specification file consists of two sections:
    itemization(
    it() The specification file's first section is tt(flexc++)'s
        emi(symbol area), used to define symbols, like a i(mini scanner), or
emi(options). The following options are suggested:
        itemization(
        it() ti(%debug): includes em(debugging)
            hi(flexc++: debugging code)
        code into the code generated by tt(flexc++). Calling the member
function
            hi(setDebug)
            hi(flexc++: setDebug)
    tt(setDebug(true)) activates this debugging code at run-time. When
activated, information about the matching process is written to the
standard output stream. The execution of debug code is suppressed after
calling the member function tt(setDebug(false)).
        it() ti(%filenames): defines the base-name of the class header files
generated by tt(flexc++). By default the class name (itself using the default
tt(Scanner)) is used.
        )
    Here is the specification files' symbol area:
            verbinclude(//SYMBOLS lexer/scanner/lexer)
    it() The specification file's second section is a em(rules section) in
which the regular expressions and their associated actions are defined.
    In the example developed here,  the lexer should
copy information from the standard input stream (tt(std::cin)) to the
standard output stream (tt(std::cout)). For this  the predefined macro
ti(ECHO) can be used.  Here are the rules:
            verbinclude(//RULES lexer/scanner/lexer)
    )
